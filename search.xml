<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[期末考后的闲情偶偶记]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%9C%9F%E6%9C%AB%E8%80%83%E5%90%8E%E7%9A%84%E9%97%B2%E6%83%85%E5%81%B6%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[借着期末考big bang的日子来随手记一点: NOIP2019说短不短，说长不长，还是想这几个月把算法全学完，再去系统的做题，因为我发现每次做题肯定会碰 到不怎么会做的算法知识，这样效率太慢了，还是囫囵吞枣先吃进去，不然的话系统的、综合的难题无法做。 说到学算法，突然想起来，蒟蒻的基础算法其实十分的差劲，寒假应该会慢慢做起来，太羞耻了！！！ 寒假掐去]]></content>
      <categories>
        <category>自娱自乐</category>
      </categories>
      <tags>
        <tag>闲情偶记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2010题解]]></title>
    <url>%2F2019%2F01%2F17%2FP2010%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[蒟蒻来这只是给各位大佬看看我鬼畜的码风的 题目传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;string s1,s2;int ans;bool check(string s)&#123; int len=s.length()-1; for(int i=0;i&lt;len/2;i++) &#123; if(s[i]!=s[len-i]) return false; &#125; return true;&#125;int day1[13]=&#123;-1,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int day2[13]=&#123;-1,31,29,31,30,31,30,31,31,30,31,30,31&#125;;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; if(s1==s2) &#123; if(check(s1)) printf("1\n"); else printf("0\n"); exit(0); &#125; int year1=0; for(int i=0;i&lt;4;i++) &#123; year1=year1*10+s1[i]-48; &#125; int year2=0; for(int i=0;i&lt;4;i++) &#123; year2=year2*10+s2[i]-48; &#125; int tt1=0,tt2=0; for(int i=4;i&lt;=7;i++) &#123; tt1=tt1*10+s1[i]-48; tt2=tt2*10+s2[i]-48; &#125; int t1,t2,tmp; t1=year1%100; t2=year1/100; t1=t1%10*10+t1/10; t2=t2%10*10+t2/10; tmp=t1*100+t2; //cout &lt;&lt; t1 &lt;&lt;" " &lt;&lt; t2 &lt;&lt; " " &lt;&lt; tt1 &lt;&lt; endl; if(t1&gt;=1 &amp;&amp; t1&lt;=12 &amp;&amp; tmp&gt;=tt1) &#123; if((year1%4==0 &amp;&amp; year1%100!=0) || (year1%400==0)) &#123; if(t2&gt;day2[t1]); else ans++; &#125; else&#123; if(t2&gt;day1[t1]); else ans++; &#125; &#125; t1=year2%100; t2=year2/100; t1=t1%10*10+t1/10; t2=t2%10*10+t2/10; tmp=t1*100+t2; // cout &lt;&lt; t1 &lt;&lt;" " &lt;&lt; t2 &lt;&lt; " " &lt;&lt; tt2 &lt;&lt; endl; if(t1&gt;=1 &amp;&amp; t1&lt;=12 &amp;&amp; tmp&lt;=tt2 &amp;&amp; year1!=year2) &#123; if((year2%4==0 &amp;&amp; year2%100!=0) || (year2%400==0)) &#123; if(t2&gt;day2[t1] ) ; else ans++; &#125; else&#123; if(t2&gt;day1[t1]) ; else ans++; &#125; &#125; for(int year=year1+1;year&lt;=year2-1;year++) &#123; int mon=year%100; int day=year/100; mon=mon%10*10+mon/10; day=day%10*10+day/10; if(mon&lt;1 || mon &gt;12) continue; if(day &lt;1 || day&gt;31) continue; if((year%4==0 &amp;&amp; year%100!=0) || year%400==0) &#123; if(day2[mon]&lt;day) continue; ans++; &#125; else&#123; if(day1[mon]&lt;day) continue; ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟,算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI现代诗——抚慰落榜的Oiers]]></title>
    <url>%2F2019%2F01%2F17%2FOI%E7%8E%B0%E4%BB%A3%E8%AF%97%E2%80%94%E2%80%94%E6%8A%9A%E6%85%B0%E8%90%BD%E6%A6%9C%E7%9A%84Oiers%2F</url>
    <content type="text"><![CDATA[愿NOIP未发挥好的， 落榜的， 初赛退役的， 复赛文件未打的， 文化课成绩不如人意的， 十分有压力的， 处于升学的尬尴场面的， 心情郁塞的， 被神犇压制而被看不见的， 没有存在感的， 老师父母不理解的， 被同学所轻看的， 自暴自弃的， Oiers。 快乐(也祝我自己)。 有些事情总会过去的。 o(￣▽￣)ブ]]></content>
      <categories>
        <category>自娱自乐</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2018回忆2]]></title>
    <url>%2F2019%2F01%2F17%2Fnoip2018%E5%9B%9E%E5%BF%862%2F</url>
    <content type="text"><![CDATA[继续写吧，略有疏懒之意为了放松心情，以来好好发挥，我先后在学军校园和浙大逛 不得不说，浙大的风景的确令人心旷神怡，我的心情的确也平和了不少。 吃过午饭之后，便回学军。 我愣是等了2个多钟头… 终于快要开考了考场附近人头攒动 我们就这样磨磨唧唧的进了考场。 我是较早进场的一批，当时第一名踏入考场的人，在那里惊呼，我心头很是疑惑，随后 用纸板隔出几百个机位，每个座位上都放着ThickPad与外界键鼠与电源 然后接下来的主考官公布解压密码，考生解压试卷。 紧张的答题时间中途工作人员过来发水与食物，我却到最后也没碰食物，只是抿了几口水。 轻轻松松水过了前两题，然后第三题，卡了我将近2个钟头，自以为调对了，。 然后错的我的想法是错的幸好发现t4是水题(想起了教练的话，柿子要挑软的捏，要先通读试卷),在最后15分钟，我内心咆哮的、懊悔的打了t4骗分算法。 为了与CCF规定的开考时间统一，上面大屏幕打出了时间，黑色的背景，白色的字，我只能绝望的看着时间渐渐逼近终点。我在最后5分钟检查了文件目录，虽然已经废了1=，但是还是要善始善终。 “全体选手请起立离开机位。”这句从踏进考场就一定会听到的话，从监考老师嘴里发出。 内心故作镇定的我，从椅子上离开，两腿发软的走出了考场，看着身后的学军体艺馆，我心里空荡荡的。 到火车站一句话都没说的我，在心里一遍一遍重复自己的错误 t2炸了，因为一句我以为永远也不会砸在我的头上的诅咒: 十年OI两茫茫，long long 没开见祖宗。我感觉我盯着高铁的窗户绝对有50分钟 到头来只水了个省二。 便要开始准备NOIP2019 我把我的blog签名改了一下 苔花如米小，也学牡丹开。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>noip游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2018回忆1]]></title>
    <url>%2F2019%2F01%2F17%2Fnoip2018%E5%9B%9E%E5%BF%861%2F</url>
    <content type="text"><![CDATA[蒟蒻才学疏浅，献上文章一篇。 琴瑟无端五十年,一弦一柱思华年。很平常的开始。 八月。每天8点起床 到机房9点 初赛初赛讲评 中午下去默默地吃午饭 3个小时午休(下午集训队静静的) 模拟赛急匆匆的晚饭 讲评 八月此后每一天都是这一天的重复9点下课，晚上10点到家。 八月过去了，暑假也过去了。暑假作业一字不动。 开学了。 平淡无奇的上学生活。 作业好久没写了。 月考期中考还过得去(期中考水了个校前十) 文化课老师对我态度不怎么好 比较难看我。(没事他们年纪大了) 每天挺孤独的，全校就我一个人打OI。晚上照常12:00 白天打瞌睡(唉) 十月初赛了。七天专心刷题。 初赛前停课了2天。 总算去余姚考初赛了。 前几天晚上做了噩梦。（考完也做) 考完对下答案感觉进复赛希望渺茫(当时真的很伤心) 心一横准备中考了。发成绩了，某家长:”夏天，你少估了分了。” 人生大起大落太tm刺激了。 白天打瞌睡。 晚上写题目。 赛前十天还写了日志(原本想发的) 此后的每一天都是这天的重复。去杭州。考前一天去。 到那边已经晚上9点了。 打车去宾馆 晚上杭州夜景挺好，心里有些惆怅，没想的我这个个人选手也进了复赛。 晚上敲了几个板子，就睡了。好好休息。 宾馆外夜景 第二天早上学军中学报到，顺顺利利。学军紫金港校区挺漂亮的。 附学校内景与报道所领文件 11.17 太晚了，就写到这里吧。 载洛谷blog:https://www.luogu.org/blog/Louts/noip-hui-yi-1-post]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>noip游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的半夜——线段树学习笔记2:离散化]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8D%8A%E5%A4%9C%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E7%A6%BB%E6%95%A3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[今晚完成了kuanbin带你飞的第四道例题，一道运用离散化思想的题目 这里就来总结归纳这道例题 D-Mayor’s posters POJ 2528 Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 80590 Accepted: 23189 Description The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules: Every candidate can place exactly one poster on the wall. All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown). The wall is divided into segments and the width of each segment is one byte. Each poster must completely cover a contiguous number of wall segments. They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections. Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall. Input The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers li and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered li, li+1 ,… , ri. Output For each input data set print the number of visible posters after all the posters are placed. The picture below illustrates the case of the sample input. Sample Input 1234567151 42 68 103 47 10 Sample Output 14 精简题意:在10000000长的线段上，依次使用长度不等的线段去覆盖，问可以从最外层看见多少条线段。 这里抽象题意，可以看作在长度为10000000的区间，依次染色区间[l,r],最后剩下多少种颜色 这么长的长度，直接使用nlogn数据结构无法维护，但是我们发现只有10000条线段，所以大部分空间是浪费的,可以通过离散化来压缩空间。 这里的线段树只是一个工具，核心是离散化的过程 我找到一组小数据但是十分典型，可以来模拟我们的离散化过程 依次染色的区间为 [1,10] [1,4] [6,10] 未离散化前应该是这么染的 ps: === 代表一格1234567=== === === === === === === === === === === === === === === === === === === ====== === === === === === === === === 正确答案为3 如果按普通的离散化方式进行染色 离散化: 1 2 3 4 1 4 6 101234567=== === === ====== === === ====== === === === 而这样却答案变成了2 经过观察发现，由于4与6经离散化后两个区间连在了一起，于是我们将两个若相差一格及以上的点， 加入一个点来表示他们中间的点: 1 2 3 4 5 6 7 1 2 4 5 6 7 101234567=== === === === === === ====== === === === === === ====== === === === === === 答案就便是正确的了 将离散化的核心代码进行解析 12345678910111213141516171819202122232425int tot=0;for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;lx[i],&amp;rx[i]); tot++; num[tot]=lx[i];//将l,r端点加入数组中 tot++; num[tot]=rx[i];&#125;sort(num+1,num+1+tot);//进行排序int q=unique(num+1,num+1+tot)-num-1;//离散化int m=q;//记录元素个数for(int i=1;i&lt;=m;i++)&#123; if(num[i+1]-num[i] &gt; 1) q++,num[q]=num[i]+1; //若两个相邻元素相差大于等于1格，加入中间元素&#125;sort(num+1,num+1+q);//再次排序for(int i=1;i&lt;=n;i++)&#123; L=lower_bound(num+1,num+1+q,lx[i])-num;//找到下标 R=lower_bound(num+1,num+1+q,rx[i])-num; C=i; update(1,q,1);//插入线段树&#125; 这时统计元素个数时只要看区间的lazytag为多少即可 最后上标程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define maxn 10005#define lson th&lt;&lt;1#define rson th&lt;&lt;1|1using namespace std;int vis[maxn&lt;&lt;4];int tag[maxn&lt;&lt;4];int lx[maxn&lt;&lt;4];int rx[maxn&lt;&lt;4];int num[maxn&lt;&lt;4];int n;int L,R,C;int T;int ans=0;void pushdown(int th)&#123; if(tag[th]==0) return; tag[lson]=tag[rson]=tag[th]; tag[th]=0;&#125;void update(int l,int r,int th)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; tag[th]=C; return; &#125; pushdown(th); int mid=l+r &gt;&gt;1; if(L&lt;=mid) update(l,mid,lson); if(mid&lt;R) update(mid+1,r,rson);&#125;void query(int l,int r,int th)&#123; if(tag[th]!=0) &#123; if(vis[tag[th]]==0) ans++; vis[tag[th]]=1; return; &#125; int mid=l+r &gt;&gt;1; if(l==r) return; query(l,mid,lson); query(mid+1,r,rson);&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; memset(vis,0,sizeof(vis)); memset(tag,0,sizeof(tag)); memset(num,0,sizeof(num)); scanf("%d",&amp;n); int tot=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;lx[i],&amp;rx[i]); tot++; num[tot]=lx[i]; tot++; num[tot]=rx[i]; &#125; sort(num+1,num+1+tot); int q=unique(num+1,num+1+tot)-num-1; int m=q; for(int i=1;i&lt;=m;i++) &#123; if(num[i+1]-num[i] &gt; 1) q++,num[q]=num[i]+1; &#125; sort(num+1,num+1+q); for(int i=1;i&lt;=n;i++) &#123; L=lower_bound(num+1,num+1+q,lx[i])-num; R=lower_bound(num+1,num+1+q,rx[i])-num; C=i; update(1,q,1); &#125; ans=0; query(1,q,1); printf("%d\n",ans); &#125;&#125; 做完这道题后，我对离散化的理解更加的深入与彻底了]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构,线段树,算法竞赛,离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的半夜----线段树学习笔记1]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8D%8A%E5%A4%9C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[说过以后写blog要严肃点，我现在就严肃地修改一下，删冗余，精简语言线段树,英文Segment Tree 这种树形数据结构十分容易形象地绘成图形 如图所示，线段树有以下性质: 线段树本质是棵二叉树. 线段树每个节点是代表一个区间[l,r],而每个节点的两个子树分别[l,mid],[mid+1,r]。 叶子节点l等于r且长度为1 线段树深度不超过logn 综上所述，我们可以按二叉树的建树方法，若节点编号为th,令节点的左儿子编号为th x 2,而右儿子记为th x 2+1。 kuanbin带你飞的前三道例题，是非常好的线段树入门例题，可以借此来初步理解线段树以及线段树的基本应用 A-敌兵布阵 HDU-1166C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问,输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Out 1234Case 1:63359 由题意可知,这是一个单点修改与区间询问的问题 个人习惯 12#define lson th&lt;&lt;1#define rson th&lt;&lt;1|1 由于综上线段树的性质(2),可以用这种方式来表示他们左右子节点。 分步解构 递归建树: 1234567891011121314151617void pushup(int th)&#123; sum[th]=sum[lson]+sum[rson];//简单的结合律&#125;void build(int l,int r,int th)&#123; if(l==r)//当为叶子节点时 &#123; tree[th]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,lson);//构建左节点 build(mid+1,r,rson);//构建右节点 pushup(th);//从两个子节点更新&#125; 单点修改，运用二分思想 123456789101112131415void update(int l,int r/*当前区间的左右端点*/,int pos/*所要修改的点*/,int th/*子树的编号*/,int k/*所要修改的值*/)&#123; if(l==pos &amp;&amp; r==pos)//当找到这个节点时修改 &#123; sum[th]+=k; return; &#125; int mid=(l+r)&gt;&gt;1;//一分为二 if(pos&lt;=mid) update(l,mid,pos,lson,k);//当pos在右区间时，递归右子树 else update(mid+1,r,pos,rson,k);//当pos在左区间时，递归左子树 pushup(th);//动过了当然要自下而上更新啦&#125; 时间复杂度网上大有分析，这里便不赘述 区间询问 1234567891011int query(int l,int r,int x,int y,int th)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123; return sum[th];//当被询问区间完全包含当前区间时，直接返回 &#125; int res=0; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) res+=query(l,mid,x,y,lson); if(mid&lt;y) res+=query(mid+1,r,x,y,rson); return res; &#125; 标程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define maxn 50005#define lson th&lt;&lt;1#define rson th&lt;&lt;1|1int sum[maxn*4];int a[maxn];void pushup(int th)&#123; sum[th]=sum[lson]+sum[rson];&#125;void build(int l,int r,int th)&#123; if(l==r) &#123; sum[th]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,lson); build(mid+1,r,rson); pushup(th);&#125;void update(int l,int r,int pos,int th,int k)&#123; if(l==pos &amp;&amp; r==pos) &#123; sum[th]+=k; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(l,mid,pos,lson,k); else update(mid+1,r,pos,rson,k); pushup(th);&#125;int query(int l,int r,int x,int y,int th)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123; return sum[th]; &#125; int res=0; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) res+=query(l,mid,x,y,lson); if(mid&lt;y) res+=query(mid+1,r,x,y,rson); return res; &#125;int main()&#123; int T; scanf("%d",&amp;T); for(int i=1;i&lt;=T;i++) &#123; printf("Case %d:\n",i); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); build(1,n,1); char str[7]; while(scanf("%s",str))&#123; if(str[0]=='E') break; if(str[0]=='A') &#123; int pos,k; scanf("%d%d",&amp;pos,&amp;k); update(1,n,pos,1,k); &#125; else if(str[0]=='S') &#123; int pos,k; scanf("%d%d",&amp;pos,&amp;k); update(1,n,pos,1,-1*k); &#125; else&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",query(1,n,x,y,1)); &#125; &#125; &#125;&#125; B-I Hate It HDU-1754Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 107180 Accepted Submission(s): 40245 Problem Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input 123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output 123455659HintHuge input,the C function scanf() will work better than cin 由题意可知，此题为区间最大值与单点修改，较上面A题，编码难度较为简单 这里单点修改与建树就不再赘述，因为这里只要修改pushup()函数 1234void pushup(int th)&#123; maxx[th]=max(maxx[lson],maxx[rson]);&#125; 简单的询问 1234567int query(int l,int r,int x,int y,int th)&#123; if(x&gt;r || y&lt;l) return 0; //完全没有交集的情况 if(x&lt;=l &amp;&amp; r&lt;=y) return maxx[th]; //询问区间包含当前区间 int mid=(l+r) &gt;&gt; 1; return max(query(l,mid,x,y,lson),query(mid+1,r,x,y,rson)); //递归询问&#125; 由这道题，大家应该能举一反三，写出区间最小值 标程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;iostream&gt;#define maxn 200005#define lson th&lt;&lt;1#define rson th&lt;&lt;1|1using namespace std;int maxx[maxn*4];int a[maxn];void pushup(int th)&#123; maxx[th]=max(maxx[lson],maxx[rson]);&#125;void build(int l,int r,int th)&#123; if(l==r) &#123; maxx[th]=a[l]; return; &#125; int mid=(l+r) &gt;&gt; 1; build(l,mid,lson); build(mid+1,r,rson); pushup(th);&#125;void update(int l,int r,int pos, int th ,int k)&#123; if(l==pos&amp;&amp;r==pos) &#123; maxx[th]=k; return; &#125; int mid=(l+r) &gt;&gt; 1; if(pos&lt;=mid) update(l,mid,pos,lson,k); else update(mid+1,r,pos,rson,k); pushup(th);&#125;int query(int l,int r,int x,int y,int th)&#123; if(x&gt;r || y&lt;l) return 0; if(x&lt;=l &amp;&amp; r&lt;=y) return maxx[th]; int mid=(l+r) &gt;&gt; 1; return max(query(l,mid,x,y,lson),query(mid+1,r,x,y,rson));&#125;int n,m;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; build(1,n,1); for(int i=1;i&lt;=m;i++) &#123; char str[5]; scanf("%s",str); if(str[0]=='Q') &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",query(1,n,x,y,1)); &#125; else&#123; int pos,k; scanf("%d%d",&amp;pos,&amp;k); update(1,n,pos,1,k); &#125; &#125; &#125; return 0;&#125; C-A Simple Problem with IntegersTime Limit: 5000MS Memory Limit: 131072KTotal Submissions: 147182 Accepted: 45731Case Time Limit: 2000MSDescription You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. Input The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab. Output You need to answer all Q commands in order. One answer in a line. Sample Input123456710 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4 Sample Output12345678910455915HintThe sums may exceed the range of 32-bit integers.SourcePOJ Monthly--2007.11.25, Yang Yi 我为大家大致翻译一下题干，意为需维护一个长度为N的int数组A，相对应的Q组询问，有两种操作，C l r k 意为将[l,r]区间每个数加上k,Q l r，询问[l,r]的区间和。 这便是区间修改问题。 这里要使用一种标记数组，lazytag lazytag存储在父节点上，为该区间总共需要加上的数值，所以为了维护线段树，每次向下层递归前，都要下传lazytag 我们先来看一下区间修改函数 123456789101112131415161718inline void update(ll l,/*当前区间左端点*/ll r,/*当前区间右端点*/ll x,/*所询问区间左端点*/ll y,/*所询问区间右端点*/ll th,ll k)&#123; if(x&lt;=l &amp;&amp; r&lt;=y)//若完全包含，便把值记录在tag上 &#123; add(l,r,th,k); return; &#125; pushdown(l,r,th);//递归前下传标记 ll mid=l+r &gt;&gt;1; if(x&lt;=mid) update(l,mid,x,y,lson,k); if(y&gt;mid) update(mid+1,r,x,y,rson,k); pushup(th);&#125; add函数123456inline void add(ll l,ll r,ll th,ll k)&#123; tag[th]+=k;//tag更新 sum[th]+=(r-l+1)*k;//自身维护 return;&#125; 这里有个pushdown函数，是pushup函数的反向操作12345678inline void pushdown(ll l,ll r,ll th)&#123; if(tag[th]==0) return;//若tag为0则返回 ll mid=l+r &gt;&gt;1; add(l,mid,lson,tag[th]);//下传标记 add(mid+1,r,rson,tag[th]); tag[th]=0;//别忘了清零&#125; 这里为什么只下传一层呢:因为正如之前所说，每次向下递归前都要下传标记，所以到下层标记自然会下传 所以这里的询问有了些小小的变化 12345678910111213ll query(ll l,ll r,ll x,ll y,ll th)&#123; if(x&lt;=l &amp;&amp; r&lt;=y) &#123; return sum[th]; &#125; ll mid=l+r &gt;&gt;1; ll res=0; pushdown(l,r,th); if(x&lt;=mid) res+=query(l,mid,x,y,lson); if(y&gt;mid) res+=query(mid+1,r,x,y,rson); return res;&#125; 然而为什么要用longlong呢，题中明明说是int数组 这时我们再通读题面，会发现一行话 The sums may exceed the range of 32-bit integers. 区间和可能会超过32位int类型 这便是要用longlong的原因 标程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define lson th&lt;&lt;1#define rson th&lt;&lt;1|1#define maxn 100005typedef long long ll;using namespace std;ll sum[maxn*4];ll a[maxn];ll n,m;ll tag[maxn*4];inline void add(ll l,ll r,ll th,ll k)&#123; tag[th]+=k; sum[th]+=(r-l+1)*k; return;&#125;inline void pushup(ll th)&#123; sum[th]=sum[lson]+sum[rson]; return;&#125;inline void pushdown(ll l,ll r,ll th)&#123; if(tag[th]==0) return; ll mid=l+r &gt;&gt;1; add(l,mid,lson,tag[th]); add(mid+1,r,rson,tag[th]); tag[th]=0;&#125;inline void build(ll l,ll r,ll th)&#123; if(l==r) &#123; sum[th]=a[l]; return; &#125; ll mid=l+r &gt;&gt; 1; build(l,mid,lson); build(mid+1,r,rson); pushup(th);&#125;inline void update(ll l,ll r,ll x,ll y,ll th,ll k)&#123; if(x&lt;=l &amp;&amp; r&lt;=y) &#123; add(l,r,th,k); return; &#125; pushdown(l,r,th); ll mid=l+r &gt;&gt;1; if(x&lt;=mid) update(l,mid,x,y,lson,k); if(y&gt;mid) update(mid+1,r,x,y,rson,k); pushup(th);&#125;ll query(ll l,ll r,ll x,ll y,ll th)&#123; if(x&lt;=l &amp;&amp; r&lt;=y) &#123; return sum[th]; &#125; ll mid=l+r &gt;&gt;1; ll res=0; pushdown(l,r,th); if(x&lt;=mid) res+=query(l,mid,x,y,lson); if(y&gt;mid) res+=query(mid+1,r,x,y,rson); return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); &#125; build(1,n,1); while(m--) &#123; char str[5]; scanf("%s",str); if(str[0]=='C') &#123; ll x,y,k; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;k); update(1,n,x,y,1,k); &#125; else&#123; ll x,y; scanf("%lld %lld",&amp;x,&amp;y); printf("%lld\n",query(1,n,x,y,1)); &#125; &#125;&#125; 理解了之后代码难度并不是非常大，毕竟只是最最基础的应用而已。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线段树,数据结构,算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于博客搬运事宜]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%90%E4%BA%8B%E5%AE%9C%2F</url>
    <content type="text"><![CDATA[这是最近拿hexo搭的blog我最近实在没有时间，搬运工作会在寒假慢慢的做起来。]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
